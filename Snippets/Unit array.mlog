Initialize:
	set status "INITIALIZE"
	set unitType @flare
	set maxUnits 4
	set arrayLength 24
	set maxDistance 30
	set releaseWaitSecs 10

	set error " "

	set switch switch1
	jump NoSwitch equal switch null
	jump TooMany greaterThan maxUnits arrayLength

	GetId:
		op shl procId @thisx 9
		op add procId procId @thisy

	op sub releaseX @thisx 2
	op sub releaseY @thisy 5

	op add nearX @thisx 1
	op add nearY @thisy 1
	op add farX @thisx 15
	op add farY @thisy 15

	op mul releaseWaitMs releaseWaitSecs 1000
	sensor lastActive switch @enabled

#-------------------------------------------------
Preflag:
#-------------------------------------------------
	set flagStart @time
	Count:
		set firstUnit null
		set flagged 0
		set free 0
		set units 0
		set status "COUNT"
	
		CountLoop:
			ubind unitType
			jump NoUnits equal @unit null
			sensor isDead @unit @dead
			jump CountLoop equal isDead true
	
			jump FinishCount equal firstUnit @unit
			jump CountProcess notEqual firstUnit null
			set firstUnit @unit
	
		CountProcess:
			sensor flag @unit @flag
			jump CountFlagged equal flag procId
			jump CountFree equal flag 0
			jump NextCount always
			
		CountFlagged:
			jump DoCountFlagged greaterThanEq flagged maxUnits
			SaveFlagged: 
				set unit @unit
				set arrayIndex flagged
				op add arrayReturn @counter 1
				jump ArraySet always
	
			DoCountFlagged:
				op add flagged flagged 1
				jump NextCount always
	
		CountFree:
			sensor controlled @unit @controlled
			jump NextCount greaterThanEq controlled 2
			op add free free 1
		
		NextCount:
			op add units units 1
			jump CountLoop always
	
		FinishCount:
			jump NoUnits equal units 0
			jump Flag lessThan flagged maxUnits
			jump Unflag greaterThan flagged maxUnits
			jump FlagDone always
	
	Flag:
		op sub toFlag maxUnits flagged
		op min toFlag toFlag free
		jump FlagDone lessThanEq toFlag 0
	
		set status "FLAG"
		set firstUnit null
		set tooFar 0
	
		FlagLoop:
			ubind unitType
			sensor isDead @unit @dead
			jump FlagLoop equal isDead true
	
			jump FinishFlag equal firstUnit @unit
			jump FlagProcess notEqual firstUnit null
			set firstUnit @unit
	
		FlagProcess:
			sensor flag @unit @flag
			jump NextFlag notEqual flag 0
	
		ProcessFree: 
			sensor controlled @unit @controlled
			jump NextFlag greaterThanEq controlled 2
	
			CheckDistance:
				sensor x @unit @x
				sensor y @unit @y
				op sub xDiff @thisx x
				op sub yDiff @thisy y
				op len distance xDiff yDiff
				jump FlagUnit lessThanEq distance maxDistance
				op add tooFar tooFar 1
				jump NextFlag always
	
			FlagUnit:
				ucontrol flag procId
				set arrayIndex flagged
				set unit @unit
				op add arrayReturn @counter 1
				jump ArraySet always
				op sub toFlag toFlag 1
				op add flagged flagged 1
		
		NextFlag:
			jump FlagLoop greaterThan toFlag 0
	
		FinishFlag:
			jump FlagDone always
	
	Unflag:
		op sub toUnflag flagged maxUnits
		jump FlagDone lessThanEq toUnflag 0
	
		set status "UNFLAG"		
		set firstUnit null
	
		UnflagLoop:
			ubind unitType
			sensor isDead @unit @dead
			jump UnflagLoop equal isDead true
	
			jump FinishUnflag equal firstUnit @unit
			jump UnflagProcess notEqual firstUnit null
			set firstUnit @unit
	
		UnflagProcess:
			sensor flag @unit @flag
			jump NextUnflag notEqual flag procId
	
		UnflagUnit:
			ucontrol flag 0
			op sub toUnflag toUnflag 1
			op sub flagged flagged 1
		
		NextUnflag:
			jump UnflagLoop lessThanEq flagged maxUnits
		
		FinishUnflag:
			jump FlagDone always
	
		FlagDone:

	GetStartUnit:
		set arrayIndex 0
		op add arrayReturn @counter 1
		jump ArrayGet always
		jump Preflag equal unit null
		op sub flagTime @time flagStart
	
		ucontrol approach @thisx @thisy 5

	set status "START"
	set arrayIndex 0
	set releaseStart @time

Start:
	sensor active switch @enabled
	jump ActiveChanged notEqual active lastActive
	jump Reset equal active false

Process:
	set cycleStart @time
	op add arrayReturn @counter 1
	jump ArrayGet always
	jump Next equal unit null
		
	ubind unit
	set releaseStart @time
	set status "MOVING"

	MoveNear:
		ucontrol approach nearX nearY 3
		ucontrol within nearX nearY 4 isNear
		jump Next equal isNear false

	MoveFar:
		ucontrol approach farX farY 3
		ucontrol within farX farY 4 isFar
		jump MoveNear equal isFar true

	Next:
		op add arrayIndex arrayIndex 1
		jump Start lessThan arrayIndex flagged

	FinishGroup:
		set arrayIndex 0
		op sub cycleTime @time cycleStart
		jump Start always

ActiveChanged:
	set lastActive active
	jump Initialize equal active true

Reset:
	jump Start equal status "IDLE"
	jump Release equal status "RELEASING"
	op sub releaseWait @time releaseStart
	jump Start lessThan releaseWait releaseWaitMs

Stop:
	set status "STOPPING"
	set arrayIndex 0
	StopLoop:
		op add arrayReturn @counter 1
		jump ArrayGet always
		jump StopNext equal unit null
		
		ubind unit
		ucontrol stop

		StopNext:
			op add arrayIndex arrayIndex 1
			jump StopLoop lessThan arrayIndex maxUnits
	FinishStop:
		set status "RELEASING"
		jump Start always

Release:

	set arrayIndex 0
	ReleaseLoop:
		op add arrayReturn @counter 1
		jump ArrayGet always
		jump ReleaseNext equal unit null
		
		ubind unit
		ucontrol stop
		ucontrol flag 0
		ucontrol move releaseX releaseY

		ReleaseNext:
			op add arrayIndex arrayIndex 1
			jump ReleaseLoop lessThan arrayIndex maxUnits
		
	FinishRelease:
		set status "IDLE"
		set releaseStart @time
		jump Start always

#-------------------------------------------------
Errors:
#-------------------------------------------------
TooMany:
	set error "Max 10 units supported"
	jump Error always
	
NoSwitch:
	set error "Need switch"
	jump Error always

NoUnits:
	set error "No free units"
	jump Preflag always

TooFar:
	set error "Some units are too far"
	jump Preflag always

Error:
	# idle here until user looks at error and restarts
	jump Error always

#-------------------------------------------------
Array:
#-------------------------------------------------
ArraySet:
	op mul offset arrayIndex 2
	op add @counter @counter offset

	set unit0 unit
	set @counter arrayReturn
	set unit1 unit
	set @counter arrayReturn
	set unit2 unit
	set @counter arrayReturn
	set unit3 unit
	set @counter arrayReturn
	set unit4 unit
	set @counter arrayReturn
	set unit5 unit
	set @counter arrayReturn
	set unit6 unit
	set @counter arrayReturn
	set unit7 unit
	set @counter arrayReturn
	set unit8 unit
	set @counter arrayReturn
	set unit9 unit
	set @counter arrayReturn

	set unit10 unit
	set @counter arrayReturn
	set unit11 unit
	set @counter arrayReturn
	set unit12 unit
	set @counter arrayReturn
	set unit13 unit
	set @counter arrayReturn
	set unit14 unit
	set @counter arrayReturn
	set unit15 unit
	set @counter arrayReturn
	set unit16 unit
	set @counter arrayReturn
	set unit17 unit
	set @counter arrayReturn
	set unit18 unit
	set @counter arrayReturn
	set unit19 unit
	set @counter arrayReturn

	set unit20 unit
	set @counter arrayReturn
	set unit21 unit
	set @counter arrayReturn
	set unit22 unit
	set @counter arrayReturn
	set unit23 unit
	set @counter arrayReturn

ArrayGet:
	op mul offset arrayIndex 2
	op add @counter @counter offset

	set unit unit0
	set @counter arrayReturn
	set unit unit1
	set @counter arrayReturn
	set unit unit2
	set @counter arrayReturn
	set unit unit3
	set @counter arrayReturn
	set unit unit4
	set @counter arrayReturn
	set unit unit5
	set @counter arrayReturn
	set unit unit6
	set @counter arrayReturn
	set unit unit7
	set @counter arrayReturn
	set unit unit8
	set @counter arrayReturn
	set unit unit9
	set @counter arrayReturn

	set unit unit10
	set @counter arrayReturn
	set unit unit11
	set @counter arrayReturn
	set unit unit12
	set @counter arrayReturn
	set unit unit13
	set @counter arrayReturn
	set unit unit14
	set @counter arrayReturn
	set unit unit15
	set @counter arrayReturn
	set unit unit16
	set @counter arrayReturn
	set unit unit17
	set @counter arrayReturn
	set unit unit18
	set @counter arrayReturn
	set unit unit19
	set @counter arrayReturn

	set unit unit20
	set @counter arrayReturn
	set unit unit21
	set @counter arrayReturn
	set unit unit22
	set @counter arrayReturn
	set unit unit23
	set @counter arrayReturn