Initialize:
	set status "INITIALIZE"
	set unitType @flare
	set maxUnits 4
	set maxArrayLength 10
	set maxDistance 30
	set releaseWaitSecs 10

	set error " "

	set switch switch1
	jump NoSwitch equal switch null
	jump TooMany greaterThan maxUnits maxArrayLength
	jump GetId always

	TooMany:
		set error "Max 10 units supported"
		jump Error always
	
	NoSwitch:
		set error "Need switch"
		jump Error always

Error:
	# idle here until user looks at error and restarts
	jump Error always

	GetId:
		op shl procId @thisx 9
		op add procId procId @thisy

	op sub releaseX @thisx 2
	op sub releaseY @thisy 5

	op add nearX @thisx 1
	op add nearY @thisy 1
	op add farX @thisx 15
	op add farY @thisy 15

	op mul releaseWaitMs releaseWaitSecs 1000
	sensor lastActive switch @enabled

Preflag:
Count:
	set firstUnit null
	set flagged 0
	set free 0
	set units 0
	set neededFlags 0
	set status "COUNT"

	CountLoop:
		ubind unitType
		jump NoUnits equal @unit null
		sensor isDead @unit @dead
		jump CountLoop equal isDead true

		jump FinishCount equal firstUnit @unit
		jump CountProcess notEqual firstUnit null
		set firstUnit @unit

	CountProcess:
		sensor flag @unit @flag
		jump CountFlagged equal flag procId
		jump CountFree equal flag 0
		jump NextCount always
		
	CountFlagged:
		op add flagged flagged 1
		jump NextCount always

	CountFree:
		sensor controlled @unit @controlled
		jump NextCount greaterThanEq controlled 2
		op add free free 1
	
	NextCount:
		op add units units 1
		jump CountLoop always

	FinishCount:
		jump NoUnits equal units 0
		jump Flag lessThan flagged maxUnits
		jump Unflag greaterThan flagged maxUnits
		jump FlagDone always

Flag:
	op sub neededFlags maxUnits totalFlagged
	op min neededFlags neededFlags free

	set status "FLAG"
	set firstUnit null
	set flagged 0

	FlagLoop:
		ubind unitType
		sensor isDead @unit @dead
		jump FlagLoop equal isDead true

		jump FinishFlag equal firstUnit @unit
		jump FlagProcess notEqual firstUnit null
		set firstUnit @unit

	FlagProcess:
		sensor flag @unit @flag
		jump ProcessFlagged equal flag procId
		jump ProcessFree equal flag 0
		jump NextFlag always
		
	ProcessFlagged:
		set unit @unit
		set arrayIndex flagged
		op add arrayReturn @counter 1
		jump ArraySet always
		op add flagged flagged 1
	jump NextFlag always

	ProcessFree:
		sensor controlled @unit @controlled
		jump NextFlag greaterThanEq controlled 2

		CheckDistance:
			sensor x @unit @x
			sensor y @unit @y
			op sub xDiff @thisx x
			op sub yDiff @thisy y
			op len distance xDiff yDiff
			jump NextFlag greaterThan distance maxDistance

		Flag:
			ucontrol flag procId
			set arrayIndex flagged
			set unit @unit
			op add arrayReturn @counter 1
			jump ArraySet always
			op sub neededFlags neededFlags 1
			op add flagged flagged 1
	
	NextFlag:
		jump FlagLoop greaterThan neededFlags 0

	FinishFlag:
		jump FlagDone always

Unflag:
	op sub neededFlags maxUnits totalFlagged
	op min neededFlags neededFlags free

	set status "UNFLAG"		
	set firstUnit null
	set flagged 0

	UnflagLoop:
		ubind unitType
		sensor isDead @unit @dead
		jump UnflagLoop equal isDead true

		jump FinishUnflag equal firstUnit @unit
		jump UnflagProcess notEqual firstUnit null
		set firstUnit @unit

	UnflagProcess:
		sensor flag @unit @flag
		jump NextUnflag notEqual flag procId
		jump UnflagUnit greaterThanEq flagged maxUnits

		SaveFlagged: 
			set unit @unit
			set arrayIndex flagged
			op add arrayReturn @counter 1
			jump ArraySet always
			op add flagged flagged 1
		jump NextFlag always

	UnflagUnit:
		ucontrol flag 0
		op sub neededFlags neededFlags 1
	
	NextUnflag:
		jump UnflagLoop greaterThan neededFlags 0
	
	FinishUnflag:
		jump FlagDone always

	NoUnits:
		set error "No free units"
		jump Preflag always

	FlagDone:

	GetStartUnit:
		set arrayIndex 0
		op add arrayReturn @counter 1
		jump ArrayGet always
		jump Preflag equal unit null
		ucontrol approach @thisx @thisy 5

	set status "START"

Start:
	op sub releaseWait @time releaseStart
	jump Release greaterThanEq releaseWait releaseWaitMs
	
	sensor active switch @enabled
	jump ActiveChanged notEqual active lastActive
	jump Reset equal active false

Process:
	set status "PROCESSING"
	ProcessLoop:
		op add arrayReturn @counter 1
		jump ArrayGet always
		# ignore empty slots
		jump Next equal unit null
		
		ubind unit

StartRun:
	set releaseStart @time
	set status "MOVING"

	MoveNear:
		ucontrol approach nearX nearY 3
		ucontrol within nearX nearY 4 isNear
		jump Next equal isNear false

	MoveFar:
		ucontrol approach farX farY 3
		ucontrol within farX farY 4 isFar
		jump MoveNear equal isFar true

	Next:
		op add arrayIndex arrayIndex 1
		jump Start lessThan arrayIndex totalFlagged

FinishGroup:
	set arrayIndex 0
	jump Start always

ActiveChanged:
	set lastActive active
	jump Initialize equal active true

Reset:
	jump Start equal status "IDLE"

Stop:
	set status "STOPPING"
	set arrayIndex 0
	StopLoop:
		op add arrayReturn @counter 1
		jump ArrayGet always
		jump StopNext equal unit null
		
		ubind unit
		ucontrol stop

		StopNext:
			op add arrayIndex arrayIndex 1
			jump StopLoop lessThan arrayIndex arrayLength
		
	FinishStop:
		set status "RELEASING"
		jump Start always

Release:
	set status "RELEASE"
	set arrayIndex 0
	ReleaseLoop:
		op add arrayReturn @counter 1
		jump ArrayGet always
		jump ReleaseNext equal unit null
		
		ubind unit
		ucontrol stop
		ucontrol flag 0
		ucontrol move releaseX releaseY

		ReleaseNext:
			op add arrayIndex arrayIndex 1
			jump ReleaseLoop lessThan arrayIndex arrayLength
		
	FinishRelease:
		set status "IDLE"
		set releaseStart @time
		jump Start always

ArraySet:
	# storing the arrayIndex values is for debugging
	# can take out when debugged
	op mul offset arrayIndex 3
	op add offset offset 1
	op add @counter @counter offset

	set unit0 unit
	set i0 arrayIndex
	set @counter arrayReturn
	set unit1 unit
	set i1 arrayIndex
	set @counter arrayReturn
	set unit2 unit
	set i2 arrayIndex
	set @counter arrayReturn
	set unit3 unit
	set i3 arrayIndex
	set @counter arrayReturn
	set unit4 unit
	set i4 arrayIndex
	set @counter arrayReturn
	set unit5 unit
	set i5 arrayIndex
	set @counter arrayReturn
	set unit6 unit
	set i6 arrayIndex
	set @counter arrayReturn
	set unit7 unit
	set i7 arrayIndex
	set @counter arrayReturn
	set unit8 unit
	set i8 arrayIndex
	set @counter arrayReturn
	set unit9 unit
	set i9 arrayIndex
	set @counter arrayReturn

ArrayGet:
	op mul offset arrayIndex 2
	op add offset offset 1
	op add @counter @counter offset

	set unit unit0
	set @counter arrayReturn
	set unit unit1
	set @counter arrayReturn
	set unit unit2
	set @counter arrayReturn
	set unit unit3
	set @counter arrayReturn
	set unit unit4
	set @counter arrayReturn
	set unit unit5
	set @counter arrayReturn
	set unit unit6
	set @counter arrayReturn
	set unit unit7
	set @counter arrayReturn
	set unit unit8
	set @counter arrayReturn
	set unit unit9
	set @counter arrayReturn