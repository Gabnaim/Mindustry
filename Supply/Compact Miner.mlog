set name "Miner"

Initialize:
	set unitType @quasar
	set maxUnits 3
	set minedOre @scrap
	set dropToCore false
	set maxDistance 100 # do not bind if further away
	set releaseWaitSecs 300
	
	set useCoords false
	set oreX 0
	set oreY 0

	set status "INITIALIZE"
	set error " "

	set miningRange 8.75
	set dropRange 7
	
	op shl procId @thisx 10
	op add procId procId @thisy

	op add releaseX @thisx 2
	op add releaseY @thisy -8

	set arrayLength 12
	jump TooMany greaterThan maxUnits arrayLength

	GetLinks:
		set l 0
		set found 0
		LinkLoop:
			getlink link l
			sensor type link @type
			jump FoundSwitch equal type @switch
			sensor buildingCap link @itemCapacity
			jump FoundTarget greaterThanEq buildingCap 100
			jump NextLink always
		FoundSwitch:
			set switch link
			jump NextLink always
		FoundTarget:
			set dropTarget link
		NextLink:
			op add l l 1
			jump LinkLoop lessThan l @links

		jump LinkLoop equal switch null
		jump CheckConfig equal dropToCore true
		jump LinkLoop equal dropTarget null

	CheckConfig:
		jump Preflag equal useCoords false
		op add oreCheck oreX oreY
		jump Preflag greaterThan oreCheck 0
		set error "need coords"
		jump CheckConfig always

#-------------------------------------------------
Preflag:
#-------------------------------------------------
	set flagStart @time
	Count:
		set status "COUNT"
		set flagged 0
		set free 0
		set units 0
		set tooFar 0
		
		ubind unitType
		jump NoUnits equal @unit null
		set firstUnit @unit
		jump CountProcess always
		
		CountLoop:
			ubind unitType
			jump FinishCount equal firstUnit @unit
	
		CountProcess:
			sensor isDead @unit @dead
			jump CountLoop equal isDead true
			sensor flag @unit @flag
			jump CountFree equal flag 0
			jump NextCount notEqual flag procId
			jump CountFlagged greaterThanEq flagged maxUnits

			SaveFlagged: 
				set unit @unit
				set arrayIndex flagged
				op add arrayReturn @counter 1
				jump ArraySet always
	
			CountFlagged:
				op add flagged flagged 1
				jump NextCount always
	
			CountFree:
				op add free free 1
		
		NextCount:
			op add units units 1
			jump CountLoop always
	
		FinishCount:
			jump FlagDone equal flagged maxUnits
			jump Unflag greaterThan flagged maxUnits
	
	Flag:
		jump FlagDone equal free 0

		set status "FLAG"
		ubind unitType
		set firstUnit @unit
		jump FlagProcess always
	
		FlagLoop:
			ubind unitType
			jump FinishFlag equal firstUnit @unit
	
		FlagProcess:
			sensor isDead @unit @dead
			jump FlagLoop equal isDead true
			sensor flag @unit @flag
			jump NextFlag notEqual flag 0
	
		ProcessFree: 
			sensor controlled @unit @controlled
			jump NextFlag greaterThanEq controlled 2
	
			CheckDistance:
				sensor x @unit @x
				sensor y @unit @y
				op sub xDiff @thisx x
				op sub yDiff @thisy y
				op len distance xDiff yDiff
				jump UnitTooFar greaterThan distance maxDistance
	
			FlagUnit:
				ucontrol flag procId
				set arrayIndex flagged
				set unit @unit
				op add arrayReturn @counter 1
				jump ArraySet always
				op add flagged flagged 1

		UnitTooFar:
			op add tooFar tooFar 1
		
		NextFlag:
			jump FlagLoop lessThan flagged maxUnits
		
		FinishFlag:
			jump FlagDone equal flagged maxUnits
			jump NoUnits equal flagged 0
			jump FlagDone always
	
	Unflag:
		set status "UNFLAG"		

		ubind unitType
		set firstUnit @unit
		jump UnflagProcess always
	
		UnflagLoop:
			ubind unitType
			jump FlagDone equal firstUnit @unit
	
		UnflagProcess:
			sensor isDead @unit @dead
			jump UnflagLoop equal isDead true
			sensor flag @unit @flag
			jump NextUnflag notEqual flag procId
	
		UnflagUnit:
			ucontrol flag 0
			op sub flagged flagged 1
		
		NextUnflag:
			jump UnflagLoop greaterThan flagged maxUnits
		
		FlagDone:
			op sub flagTime @time flagStart
			jump Preflag equal maxUnits 0
			jump NoUnits equal flagged 0
		#-------------------------------------------------			

	GetStartUnit:
		set arrayIndex 0
		op add arrayReturn @counter 1
		jump ArrayGet always
		jump Preflag equal unit null

		ubind unit
		sensor cap unit @itemCapacity
		sensor range unit @range
		op sub range range 1
		op min dropRange dropRange range
		op add coreRange 27.5 miningRange
	
		ulocate building core false 0 coreX coreY coreFound core
		jump Preflag equal coreFound false
		jump GetDropCoords equal dropToCore false
		set dropTarget core
		
	GetDropCoords:
		sensor dropX dropTarget @x
		sensor dropY dropTarget @y

	op mul releaseWaitMs releaseWaitSecs 1000
	set oreFound false
	set status "START"
	set error " "
	set arrayIndex 0
	set tooFar 0
	set releaseStart @time
	sensor lastActive switch @enabled

#-------------------------------------------------
MainLoop:
#-------------------------------------------------
Start:
	sensor active switch @enabled
	jump ActiveChanged notEqual active lastActive
	jump Reset equal active false
	op sub releaseWait @time releaseStart
	jump Reset greaterThanEq releaseWait releaseWaitMs

CheckUnit:
	op add arrayReturn @counter 1
	jump ArrayGet always
	
	jump Rebind equal unit null
	sensor isDead unit @dead
	jump Rebind equal isDead true
	sensor flag unit @flag
	jump Reflag equal flag 0
	jump Rebind notEqual flag procId
	jump DoStuff always

Rebind:
FindRecruit:
	set status "FIND"

	ubind unitType
	jump NoUnits equal @unit null
	set tooFar 0
	set firstUnit @unit
	jump ProcessRecruit always

	FindLoop:
		ubind unitType
		jump NoReserves equal firstUnit @unit
		sensor isFirstDead firstUnit @dead
		jump NoReserves equal isFirstDead true
	
	ProcessRecruit:
		sensor isDead @unit @dead
		jump FindLoop equal isDead true

		sensor flag @unit @flag
		jump FindLoop notEqual flag 0

		sensor controlled @unit @controlled
		jump FindLoop greaterThanEq controlled 2

		CheckRecruitDistance:
			sensor x @unit @x
			sensor y @unit @y
			op sub xDiff @thisx x
			op sub yDiff @thisy y
			op len distance xDiff yDiff
			jump Reflag lessThanEq distance maxDistance
			op add tooFar tooFar 1
		jump FindLoop always
	
	Reflag:
		ucontrol flag procId
		set unit @unit
		op add arrayReturn @counter 1
		jump ArraySet always
		op add flagged flagged 1
		jump FindDone always
	
	NoReserves:
		jump Next equal unit null
		set unit null
		op add arrayReturn @counter 1
		jump ArraySet always
		jump Next always

	FindDone:
		set releaseStart @time

#-------------------------------------------------
DoStuff:
#-------------------------------------------------
SelectAction:
	ubind unit
	jump FindOre equal oreFound false
	set status "MINING"
	sensor isMining @unit @mining
	sensor carried @unit @totalItems
	sensor carriedItem @unit @firstItem

	jump Mine equal carried 0
	jump DumpUnneeded notEqual carriedItem minedOre
	jump DropItems greaterThanEq carried cap
	jump Mine always

DumpUnneeded:
	ucontrol itemDrop @air 999
	sensor carried @unit @totalItems
	jump SelectAction greaterThan carried 0
	jump Mine always

DropItems:
	ucontrol boost true
	ucontrol approach dropX dropY dropRange
	ucontrol within dropX dropY dropRange isNearDrop
	jump Next equal isNearDrop false

	set dropI 0
	DropLoop:
		ucontrol itemDrop dropTarget 999
		sensor carried @unit @totalItems
		jump Next equal carried 0
		op add dropI dropI 1
		jump DropLoop lessThan dropI 100
	jump Next always

Mine:
	set releaseStart @time
	ucontrol mine oreX oreY
	ucontrol within oreX oreY miningRange isNearMine
	jump Next equal isNearMine true
	ucontrol boost true
	ucontrol approach oreX oreY miningRange

Next:
	op add arrayIndex arrayIndex 1
	jump Start lessThan arrayIndex maxUnits

FinishGroup:
	set arrayIndex 0
	jump Start always

FindOre:
	# Use this unit to find the nearest ore source
	set status "LOCATEORE"

	jump SearchNearDrop equal useCoords false
	SearchAtCoords:
		ucontrol within oreX oreY 1 isNear
		jump CheckBlock equal isNear true
		ucontrol boost true
		ucontrol move oreX oreY 
		jump SearchAtCoords always

		CheckBlock:
			ucontrol getBlock oreX oreY type building floor
			jump NoOre notEqual type @air
		
			op add floorReturn @counter 1
			jump GetMinedFloor always

			jump OreFound equal minedFloor floor
			jump NoOre notEqual minedOre @sand
		CheckSand:
			jump OreFound equal floor @darksand
			jump NoOre always
		
	SearchNearDrop:
		GoToDrop:
			ucontrol within dropX dropY 1 isNearDrop
			jump LocateOre equal isNearDrop true
			ucontrol boost true
			ucontrol approach dropX dropY 1
			jump GoToDrop always
		
		LocateOre:
			ulocate ore core true minedOre oreX oreY oreFound oreMine
			jump OreFound equal oreFound true

	NoOre:
		set error "No ore found"
		jump Error always

	OreFound:
		set releaseStart @time
		set oreFound true
		op sub oreCoreDistX coreX oreX
		op sub oreCoreDistY coreY oreY
		op len oreCoreDist oreCoreDistX oreCoreDistY
		jump DropEarly lessThanEq oreCoreDist coreRange

		op sub oreDropDistX dropX oreX
		op sub oreDropDistY dropY oreY
		op len oreDropDist oreDropDistX oreDropDistY
		op add targetRange miningRange dropRange
		jump Start lessThanEq targetRange oreDropDist

	DropEarly:
		# if the mine is near the core, we need to drop
		# before full to prevent auto drop to core
		op mul cap cap 0.6
		op floor cap cap
		jump Start always

#--------------------------------------------------
WrapUp:
#--------------------------------------------------

ActiveChanged:
	set lastActive active
	jump Initialize equal active true
	jump Stop always

Reset:
	jump Start equal status "IDLE"
	jump Release equal status "RELEASING"

Stop:
	set status "STOPPING"
	set arrayIndex 0
	StopLoop:
		op add arrayReturn @counter 1
		jump ArrayGet always
		jump StopNext equal unit null
		
		ubind unit
		ucontrol stop

		StopNext:
			op add arrayIndex arrayIndex 1
			jump StopLoop lessThan arrayIndex maxUnits
		
Release:
	set status "RELEASING"
	op sub releaseWait @time releaseStart
	jump Start lessThan releaseWait releaseWaitMs

	set arrayIndex 0
	ReleaseLoop:
		op add arrayReturn @counter 1
		jump ArrayGet always
		jump ReleaseNext equal unit null
		
		ubind unit
		ucontrol flag 0
		ucontrol move releaseX releaseY

		ReleaseNext:
			op add arrayIndex arrayIndex 1
			jump ReleaseLoop lessThan arrayIndex maxUnits
		
	FinishRelease:
		set status "IDLE"
		set releaseStart @time
		jump Start always

GetMinedFloor:
	sensor id minedOre @id
	op mul offset id 2
	op add offset offset 1
	op add floorJump @counter offset
	set @counter floorJump
	
	set minedFloor @ore-copper
	set @counter floorReturn
	set minedFloor @ore-lead
	set @counter floorReturn
	set minedFloor null
	set @counter floorReturn
	set minedFloor null
	set @counter floorReturn
	set minedFloor @sand-floor
	set @counter floorReturn
	set minedFloor @ore-coal
	set @counter floorReturn
	set minedFloor @ore-titanium
	set @counter floorReturn
	set minedFloor null
	set @counter floorReturn
	set minedFloor @ore-scrap
	set @counter floorReturn

#-------------------------------------------------
Errors:
#-------------------------------------------------
TooMany:
	set error "Max 12 units supported"
	jump Error always
	
NoSwitch:
	set error "Need switch"
	jump Error always

NoUnits:
	jump TooFar greaterThan tooFar 0
	set error "No free units"
	jump Preflag always

TooFar:
	set error "Some units are too far"
	jump Preflag always

Error:
	# idle here until user looks at error and restarts
	jump Error always

#-------------------------------------------------
Array:
#-------------------------------------------------
ArraySet:
	op mul offset arrayIndex 2
	op add @counter @counter offset

	set unit0 unit
	set @counter arrayReturn
	set unit1 unit
	set @counter arrayReturn
	set unit2 unit
	set @counter arrayReturn
	set unit3 unit
	set @counter arrayReturn
	set unit4 unit
	set @counter arrayReturn
	set unit5 unit
	set @counter arrayReturn
	set unit6 unit
	set @counter arrayReturn
	set unit7 unit
	set @counter arrayReturn
	set unit8 unit
	set @counter arrayReturn
	set unit9 unit
	set @counter arrayReturn

	set unit10 unit
	set @counter arrayReturn
	set unit11 unit
	set @counter arrayReturn
	
	
ArrayGet:
	op mul offset arrayIndex 2
	op add @counter @counter offset

	set unit unit0
	set @counter arrayReturn
	set unit unit1
	set @counter arrayReturn
	set unit unit2
	set @counter arrayReturn
	set unit unit3
	set @counter arrayReturn
	set unit unit4
	set @counter arrayReturn
	set unit unit5
	set @counter arrayReturn
	set unit unit6
	set @counter arrayReturn
	set unit unit7
	set @counter arrayReturn
	set unit unit8
	set @counter arrayReturn
	set unit unit9
	set @counter arrayReturn

	set unit unit10
	set @counter arrayReturn
	set unit unit11
	set @counter arrayReturn
	