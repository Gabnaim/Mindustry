Initialize:
	GetLinks:
		set memory cell1
		jump GetLinks equal memory null

	DeclareDataStructure:
		# inputs
		set FLAG_ADDR 0
		set COMMAND_ADDR 1
		set UNIT_TYPE_ADDR 2
		set X_ADDR 3
		set Y_ADDR 4
		set RADIUS_ADDR 5
		set TAG_ADDR 6 # general purpose client tag

		# outputs
		set STATUS_ADDR 10
		set TARGETX_ADDR 11
		set TARGETY_ADDR 12
		set LAST_TAG_ADDR 13
	
		# move statuses
		set IDLE 0
		set APPROACHING 1
		set STOPPING 2
		set ARRIVED 3
	
		# commands
		set NONE 0
		set MOVE 1
		set STOP 2

	set status IDLE
	set maxIndex 20

	GetUnitInfo:
		ubind unitType
		jump GetUnitInfo equal @unit null
		sensor speed @unit @speed
		op sub speed speed 1
		op div waitTime 1 speed

	set lastCommand NONE
	set lastUnitTypeId -1
	set lastInputFlag -1

Start:
	printflush message1

CheckCommand:
	read command memory COMMAND_ADDR
	read inputFlag memory FLAG_ADDR
	jump CommandChanged notEqual command lastCommand
	jump CommandChanged notEqual inputFlag lastInputFlag
	
	jump BindUnit notEqual command NONE
	jump Start always

CommandChanged:
	set lastCommand command
	read tag memory TAG_ADDR
	write tag memory LAST_TAG_ADDR
	jump StopAll equal command STOP

	read unitTypeId memory UNIT_TYPE_ADDR
	read targetX memory X_ADDR
	read targetY memory Y_ADDR
	read radius memory RADIUS_ADDR

	set firstUnit null
	set status IDLE
	write status memory STATUS_ADDR
	write targetX memory TARGETX_ADDR
	write targetY memory TARGETY_ADDR

	jump BindUnit equal unitTypeId lastUnitTypeId

UnitTypeChanged:
	lookup unit unitType unitTypeId
	op lessThan isGround unitTypeId 15
	set lastUnitTypeId unitTypeId
	set firstUnit null
	GetUnitTypeInfo:
		ubind unitType
		sensor speed @unit @speed
		op sub checkSpeed speed 1
		op div waitTime 1 checkSpeed
	
BindUnit:
	ubind unitType
	jump Start equal @unit null
	sensor isDead @unit @dead
	jump Start equal isDead true
	sensor flag @unit @flag
	jump Start notEqual flag inputFlag

	jump SelectAction notEqual firstUnit null
	set firstUnit @unit

SelectAction:
	jump Approach equal command MOVE
	jump StopAll equal command STOP
	jump Start always

Approach:
	ucontrol within targetX targetY radius isNear
	jump StopUnit equal isNear true
	ucontrol boost true
	jump GroundApproach equal ground true

	AirApproach:
		ucontrol approach targetX targetY radius
		set status APPROACHING
		write status memory STATUS_ADDR
		jump Start always
	
	GroundApproach:
		ucontrol pathfind targetX targetY 

		# We only calculate the target for the first unit. 
		# All others just do a pathfind using last target
		jump Start notEqual @unit firstUnit

		sensor startX @unit @x
		sensor startY @unit @y
		wait waitTime

		CheckMoved:
			ucontrol within startX startY 1 notMoved
			jump PathFinding equal notMoved false

		FindOpenSpot:
			sensor unitX @unit @x
			sensor unitY @unit @y
			set i 0
	
			jump AddX greaterThan unitX targetX
			set stepx -1
			AddX:
				set stepx 1
	
			jump AddY greaterThan unitY targetY
			set stepy -1
			AddY:
				set stepy 1
		
			FindOpenLoop:
				op mod xmove i 2
				jump XStep equal xmove 1
				YStep:
					op add targetY targetY stepy
				XStep:
					op add targetX targetX stepx

				ucontrol pathfind targetX targetY
				wait waitTime
				
				ucontrol within startX startY 1 notMoved
				jump PathFinding equal notMoved false

				op add i i 1
				jump FindOpenLoop lessThan i maxIndex
				
			set status IDLE
			write status memory STATUS_ADDR
			jump Start always

		PathFinding:
			set status APPROACHING
			write targetX memory TARGETX_ADDR
			write targetY memory TARGETY_ADDR
			write status memory STATUS_ADDR
			jump Start always

StopAll:
	set firstUnit @unit
	set status STOPPING
	write status memory STATUS_ADDR
	StopLoop:
		ubind unitType
		jump StopFinish equal @unit null
		sensor isDead @unit @dead
		jump StopLoop equal isDead true
		sensor flag @unit @flag
		jump StopLoop notEqual flag inputFlag
		
		ucontrol stop
		ucontrol boost false
		jump StopLoop notEqual @unit firstUnit

	StopFinish:
		set status IDLE
		write 0 memory TARGETX_ADDR
		write 0 memory TARGETY_ADDR
		write status memory STATUS_ADDR
		jump Start always
			
StopUnit:
	ucontrol stop
	ucontrol boost false
	jump StopRest equal status STOPPING
	jump StopFirst equal @unit firstUnit
	jump Start always

StopFirst:
	set status STOPPING
	write status memory STATUS_ADDR
	jump Start always

StopRest:
	jump Start notEqual @unit firstUnit
	set status ARRIVED 
	write status memory STATUS_ADDR
	jump Start always
	


