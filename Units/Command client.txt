Initialize:
	set unitType @dagger
	set useScout false

	GetLinks:
		set memory cell1
		jump GetLinks equal memory null
		set sorter sorter1
		jump GetLinks equal sorter null
		GetScout:
			set scout hail1
			jump DeclareDataStructure equal useScout false
			jump GetScout equal scout null
		
	DeclareDataStructure:
		# inputs
		set FLAG_ADDR 0
		set COMMAND_ADDR 1
		set UNIT_TYPE_ADDR 2
		set X_ADDR 3
		set Y_ADDR 4
		set RADIUS_ADDR 5
		set TAG_ADDR 6 # general purpose client tag

		# outputs
		set STATUS_ADDR 10
		set TARGETX_ADDR 11
		set TARGETY_ADDR 12
		set LAST_TAG_ADDR 13
	
		# move statuses
		set IDLE 0
		set APPROACHING 1
		set STOPPING 2
		set ARRIVED 3
	
		# commands
		set NONE 0
		set MOVE 1
		set STOP 2

		# action tags
		# reuse NONE 0
		set RALLY 1
		# reuse STOP 2
		set REPAIR 3
		set DEFEND 4
		set ATTACK_UNIT 5
		set ATTACK_BUILDING 6
		set ATTACK_CORE 7
		set ATTACK_SPAWN 8

	set status IDLE
	set action NONE

	set spawnRange 40
	set rallyDistanceX 10 
	set rallyDistanceY 10 
	
	GetUnitId:
		set i 0
		GetUnitIdLoop:
			lookup unit lookupUnit i
			jump SetUnitId equal lookupUnit unitType
			op add i i 1
			jump GetUnitIdLoop lessThan i 38

	SetUnitId:
		set unitId i
		op lessThan isGround unitId 15
		write unitId memory UNIT_TYPE_ADDR

	# Get the flag from the processor that is doing the flagging
	GetId:
		op shl procId @thisx 10 # first 10 bit for x
		op add procId procId @thisy # second 10 bit for y
		write procId memory FLAG_ADDR
		op shl repairId procId 1 # add an extra bit for repair
		op add repairId repairId 1

	GetStartInfo:
		ubind unitType
		jump GetStartInfo equal @unit null
		sensor range @unit @range
		sensor maxHealth @unit @maxHealth
		
		GetEnemyCore:
			ulocate building core true 0 attackX attackY coreFound building
			jump GetSpawn equal coreFound false
			jump GetRallyPoint always
			
		GetSpawn:
			ulocate spawn core true 0 attackX attackY spawnFound building
			jump Start equal spawnFound false

	GetRallyPoint:
		SetX:
			jump AddX greaterThan attackX @thisx
			op sub rallyX @thisx rallyDistanceX
			jump SetY always
			AddX:
				op add rallyX @thisx rallyDistanceX

		SetY:
			jump AddY greaterThan attackY @thisx
			op sub rallyY @thisy rallyDistanceY
			jump Start always
			AddY:
				op add rallyY @thisy rallyDistanceY
		

Start:
	printflush message1

CheckActive:
	sensor choice sorter @config
	jump ChoiceChanged notEqual choice lastChoice
	jump BindUnit notEqual choice null
	jump Start always

ChoiceChanged:
	set lastChoice choice
	jump StopAll equal choice null
	set status IDLE
	
BindUnit:
	ubind unitType
	jump Start equal @unit null
	sensor isDead @unit @dead
	jump Start equal isDead true
	sensor flag @unit @flag
	jump GetUnit equal flag procId
	jump GetUnit equal flag repairId
	jump Start notEqual flag 0
		
GetUnit:
	set currentUnit @unit
	jump AttackUnit notEqual enemy null
	ucontrol targetp null 0

CheckHealth:
	sensor health currentUnit @health
	op div healthRatio health maxHealth
	jump SelectAction equal healthRatio 1

Repair:
	ulocate building repair false 0 repairX repairY repairFound repairPoint
	jump SelectAction equal repairFound false

	write repairId memory FLAG_ADDR
	set action REPAIR
	set targetX repairX 
	set targetY repairY
	set radius 5
	ucontrol flag repairId
	jump Approach always

Heal:
	jump Start lessThan healthRatio 1
	
SelectAction:
	ucontrol flag procId
	write procId memory FLAG_ADDR
	jump Rally equal choice @copper
	jump Attack equal choice @lead
	jump Defend equal choice @metaglass
	jump Start always

Rally:
	jump Approach equal status APPROACHING
	set defend true
	set action RALLY
	set targetX rallyX
	set targetY rallyY
	set radius 5
	jump Approach always

Defend:
	set defend true
	set action DEFEND
	jump FindTargetUnit always

Attack:
	set defend false

FindTargetUnit:
	radar enemy any any distance scout 1 enemy
	jump AttackUnit notEqual enemy null
	uradar enemy any any distance 0 1 enemy
	jump AttackUnit notEqual enemy null
	jump Start equal defend true
	jump FindTargetBuilding equal spawnFound false

AttackSpawn:
	jump Approach equal status APPROACHING
	set targetX attackX
	set targetY attackY
	set radius spawnRange
	set action ATTACK_SPAWN
	jump Approach always
	
FindTargetBuilding:
	jump Approach equal status APPROACHING
	FindTurret:
		ulocate building turret true 0 targetX targetY turretFound building
		jump FindPower equal turretFound false
		sensor targetDead building @dead
		jump SelectCloserBuilding equal targetDead false
	FindPower:
		ulocate building generator true 0 targetX targetY powerFound building
		jump AttackCore equal powerFound false
		sensor targetDead building @dead
		jump AttackCore equal targetDead true
		
SelectCloserBuilding:
	sensor unitX @unit @x
	sensor unitY @unit @y
	op sub distanceX unitX targetX
	op abs distanceX distanceX
	op sub coreDistX unitX attackX
	op abs coreDistX coreDistX
	
	op sub distanceY unitY targetY 
	op abs distanceY distanceY 
	op sub coreDistY unitY attackY
	op abs coreDistY coreDistY

	op add coreDist coreDistX coreDistY
	op add targetDist distanceX distanceY
	jump AttackBuilding greaterThan coreDist targetDist

AttackCore:
	jump Approach equal status APPROACHING
	set targetX attackX
	set targetY attackY
	set radius range
	set action ATTACK_CORE

AttackBuilding:
	ucontrol target targetX targetY true
	jump Approach always
	
AttackUnit:
	ucontrol flag procId
	sensor enemyDead enemy @dead
	jump StopShooting equal enemyDead true

ApproachEnemy:
	set action ATTACK_UNIT
	sensor enemyX enemy @x
	sensor enemyY enemy @y
	ucontrol within enemyX enemyY range isNear
	jump ShootEnemy equal isNear true
	jump GroundApproachEnemy equal isGround true
	ucontrol approach enemyX enemyY range
	ucontrol targetp enemy 1
	jump Start always

GroundApproachEnemy:
	ucontrol pathFind enemyX enemyY
	jump Start always

ShootEnemy:
	ucontrol approach enemyX enemyY range
	ucontrol targetp enemy 1
	jump Start always

StopShooting:
	ucontrol targetp null 0
	set enemy null
	set action NONE
	jump Start always

Approach:
	CheckApproachStatus:
		read status memory STATUS_ADDR
		jump Arrived equal status ARRIVED
		jump StartApproach equal status IDLE
		jump Start always

	StartApproach:
		write targetX memory X_ADDR
		write targetY memory Y_ADDR
		write radius memory RADIUS_ADDR
		write action memory TAG_ADDR
		write MOVE memory COMMAND_ADDR
		jump Start always

	Arrived:
		read lastTag memory LAST_TAG_ADDR
		write NONE memory COMMAND_ADDR
		jump Heal equal lastTag REPAIR
		set action NONE
		jump Start always

StopAll:
	read status memory STATUS_ADDR
	jump StopAll equal status STOPPING
	write STOP memory COMMAND_ADDR
	jump StopAll notEqual status IDLE
	jump Start always
	
	